* Sussman's Ideas
** Abstract Representation of Programs
- Can keep track of code and annotations of it.
- Ex: Scheme with type annotations
** Emacs Tool
- UI: Can selectively show annotations, explore layers of program
- Aware of what language and encoding it's working with
- Perform transformations, analysis, transpilation
** Universal Transpiler
- Can transform code + annotations to a different language + annotations
- Can leverage Emacs' understanding of languages (TAGS, syntax highlighting, syntax navigation, linting, etc.)

* Other Ideas
** Literate Programming
- could be closely related to a way to do layered programming
- http://www.literateprogramming.com/knuthweb.pdf
** XML as abstract representation?
http://www.o-xml.org/documentation/layered-programming.html
** Coq - abstract processing
https://coq.inria.fr/a-short-introduction-to-coq
http://plv.csail.mit.edu/bedrock/
http://adam.chlipala.net/

* General Thoughts


* Questions
** What is the best way to read a program?
My thoughts: literate programming is nice but aren't always appropriate for large or self-documenting programs. Also doesn't seem that nice to maintain.
** Is it ok for the program only to be readable in emacs?
** How to input data about piece of program? Labeled fields? User-defined? How extensible?
** What's the use case?
Just carry metadata or allow for alternative structuring of programs?
** What's the philosophy?
** Module reuse/scope management? How to use other people's code?
How to reuse function from a different layer or branch?

* Literate Programming
** Pros
- Focus on readibility of code
- Optimized for reader, not the computer
- Potentially allows for rapid skimming (e.g., a good Table of Contents)
** Cons
- Have to maintain prose
- Hard to modify someone else's code

* Philosophy
** We understand programs by layers of abstraction, so we should read and write them the same way. - long term
** Less is more.

* Use case:
- Move point to a token, use a command to "expand" it
- Modify internals and extra information of the token at point
- Can repeat this in the internals of the token
** Evaluate separately or tangle then evaluate?

* Inspiration
- Literate Programming
- clojure.spec - "docs are not enough"

* example:
#+BEGIN_SRC clojure :results verbatim
  (defn main []
    (◉send
     (◉process
      (◉receive-request))))
#+END_SRC

** w/ all info inline (including unsupported features such as types)
(defn <Request> receive-request [List<Request> requests]
  "Consumes a request from the request queue. This is where documentation
   would normally live."
  (<body code>
   (...)
   (...)))

** receive-request
"Receives a queued request from pool of requests."
*** Signature
<List<Request>> -> Request
*** Body
(case (prop-of request)
      prop-one (...)
      prop-two (...)
      ...      (...))
*** Unit Tests
(...)
*** 
